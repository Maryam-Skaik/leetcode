import java.util.HashMap;

/*
 ============================================================================
  CanSum - Dynamic Programming (Memoization / Top-Down DP)
 ============================================================================
  Problem:
  Write a function `canSum(targetSum, numbers)` that returns true if the 
  targetSum can be generated by summing elements from the numbers array.
  You may use elements as many times as needed. All numbers are non-negative.

  Examples:
  canSum(7, [5,3,4,7]) -> true
  canSum(7, [2,4]) -> false
  canSum(8, [2,3,5]) -> true
  canSum(300, [7,14]) -> false (without memoization, very slow)

 ============================================================================
  PART 1: NAIVE RECURSIVE SOLUTION
 ============================================================================
  Time Complexity: O(n^m), where n = numbers.length, m = targetSum
  Space Complexity: O(m) (recursive call stack)

  Recursion Tree Example: canSum(7, [5,3,4,7])
             7
      -5    -3    -4   -7
      2     4     3     0  <- 0 is base case (true)
     ...   ...   ...   ...
  Base Cases:
   - targetSum == 0 -> true
   - targetSum < 0  -> false
*/

public class CanSumMemoization {

    // Naive recursive solution
    public boolean canSum(int targetSum, int[] numbers) {
        if (targetSum == 0) return true;  // reached target
        if (targetSum < 0) return false;  // overshoot target

        for (int num : numbers) {
            int remainder = targetSum - num;
            if (canSum(remainder, numbers)) return true;
        }

        return false;
    }

    /*
     ============================================================================
      PART 2: MEMOIZATION / TOP-DOWN DP
     ============================================================================
      Idea:
      - Many subproblems repeat, e.g., canSum(7-3) is computed multiple times
      - Store each targetSum result in a memo (HashMap<Integer, Boolean>)
      - If already computed, return stored value
      - Avoids recomputation and improves complexity to O(targetSum * n)
    */

    public boolean canSumMemo(int targetSum, int[] numbers, HashMap<Integer, Boolean> memo) {

        if (memo.containsKey(targetSum)) return memo.get(targetSum);

        if (targetSum == 0) return true;
        if (targetSum < 0) return false;

        for (int num : numbers) {
            int remainder = targetSum - num;
            if (canSumMemo(remainder, numbers, memo)) {
                memo.put(targetSum, true);
                return true;
            }
        }

        memo.put(targetSum, false);
        return false;
    }

    /*
     ============================================================================
      MEMO EXAMPLE: canSumMemo(7, [5,3,4,7])
     ============================================================================
      memo = {
        1 -> false,
        2 -> false,
        3 -> true,
        4 -> true,
        5 -> true,
        6 -> true,
        7 -> true
      }
      Each subproblem is computed once, reused when needed
      Complexity reduces from exponential to O(targetSum * numbers.length)
    */

    public static void main(String[] args) {
        CanSumMemoization solver = new CanSumMemoization();

        int[] nums1 = {2,3};
        int[] nums2 = {5,3,4,7};
        int[] nums3 = {2,4};
        int[] nums4 = {2,3,5};
        int[] nums5 = {7,14};

        System.out.println("=== Naive Recursive ===");
        System.out.println("canSum(7, [2,3]) = " + solver.canSum(7, nums1)); // true
        System.out.println("canSum(7, [5,3,4,7]) = " + solver.canSum(7, nums2)); // true
        System.out.println("canSum(7, [2,4]) = " + solver.canSum(7, nums3)); // false
        System.out.println("canSum(8, [2,3,5]) = " + solver.canSum(8, nums4)); // true
        // System.out.println("canSum(300, [7,14]) = " + solver.canSum(300, nums5)); // very slow!

        System.out.println("\n=== Memoization / Top-Down DP ===");
        HashMap<Integer, Boolean> memo = new HashMap<>();
        System.out.println("canSumMemo(7, [2,3]) = " + solver.canSumMemo(7, nums1, memo)); // true

        memo.clear();
        System.out.println("canSumMemo(7, [5,3,4,7]) = " + solver.canSumMemo(7, nums2, memo)); // true

        memo.clear();
        System.out.println("canSumMemo(7, [2,4]) = " + solver.canSumMemo(7, nums3, memo)); // false

        memo.clear();
        System.out.println("canSumMemo(8, [2,3,5]) = " + solver.canSumMemo(8, nums4, memo)); // true

        memo.clear();
        System.out.println("canSumMemo(300, [7,14]) = " + solver.canSumMemo(300, nums5, memo)); // fast now
    }
}
